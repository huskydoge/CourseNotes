#计算机组成与技术 #作业 

![image.png|1000](https://obsidian-1317758465.cos.ap-shanghai.myqcloud.com/images/20230507212951.png)

## 5.1

### 5.1.1

16*8/64 = 2



### 5.1.2

$I，J，B[I][0]$. 前两者是归纳变量，后者由于$I$是外层归纳变量，在$J$变动的时候，$B[I][0]$会被多次访问到。



### 5.1.3

$A[I][J]$，因为马上要访问到与它相邻的$A[I][J+1]$



### 5.1.4


$I，J，B[I][0]$. 前两者是归纳变量，后者由于$I$是外层归纳变量，在$J$变动的时候，$B[I][0]$会被多次访问到。


### 5.1.5
$A[J][I]$和$B[I][0]$，前者是因为马上要访问到与它相邻的$A[J+1][I]$，后者是因为$J$循环结束后将访问与它相邻的$B[I+1][J]$

### 5.1.6
首先，对于矩阵A，我们一共有$8*8000=64000$个整数。而每个块能存储2个整数，所以需要32000个块。

对于矩阵B，
* 如果是Matlab的矩阵，它对列是连续的，所以$B[I][0],I=1,2,\cdots,8$, 按照每个块能存2个整数，总共需要4个块。
* 如果是C的矩阵，它对列不连续，所以对每个$B[I][0]$它总是在一个不同的块中，需要8个块。

所以对于matlab，总共需要32004个块；而对于C，总共需要32008个块。

****

![image.png](https://obsidian-1317758465.cos.ap-shanghai.myqcloud.com/images/20230507213623.png)

## 5.2

### 5.2.1
因为有16个cache块，所以我们的标签为二进制地址的前4位，索引为后四位。Cache初始为空的情况下，必然都是miss
$$
\begin{array}{|c|c|c|c|c|}
\hline \text { 字地址 } & \text { 二进制地址 } & \text { 标记 } & \text { 索引 } & \text { 命中/未命中 } \\
\hline \text { 0x03 } & 00000011 & 0 & 3 & \mathrm{M} \\
\hline \text { 0xb4 } & 10110100 & \mathrm{~b} & 4 & \mathrm{M} \\
\hline \text { 0x2b } & 00101011 & 2 & \mathrm{~b} & \mathrm{M} \\
\hline \text { 0x02 } & 00000010 & 0 & 2 & \mathrm{M} \\
\hline \text { 0xbf } & 10111111 & \mathrm{~b} & \mathrm{f} & \mathrm{M} \\
\hline \text { 0x58 } & 01011000 & 5 & 8 & \mathrm{M} \\
\hline \text { 0xbe } & 10111110 & \mathrm{~b} & \mathrm{e} & \mathrm{M} \\
\hline \text { 0x0e } & 00001110 & 0 & \mathrm{e} & \mathrm{M} \\
\hline \text { 0xb5 } & 10110101 & \mathrm{~b} & 5 & \mathrm{M} \\
\hline \text { 0x2c } & 00101100 & 2 & \mathrm{c} & \mathrm{M} \\
\hline \text { 0xba } & 10111010 & \mathrm{~b} & \mathrm{a} & \mathrm{M} \\
\hline \text { 0xfd } & 11111101 & \mathrm{f} & \mathrm{d} & \mathrm{M} \\
\hline
\end{array}
$$

### 5.2.2
有8个cache块，每个块的大小是2个字，所以偏移的位数为1。索引是二进制地址去掉最后一位后模8得到的余数，标记则是前4位。
$$
\begin{array}{|c|c|c|c|c|c|}
\hline \text { 字地址 } & \text { 二进制地址 } & \text { 标记 } & \text { 索引 } & \text { 偏移位 } & \text { 命中/未命中 } \\
\hline \text { 0x03 } & 00000011 & 0 & 1 & 1 & \mathrm{M} \\
\hline \text { 0xb4 } & 10110100 & \mathrm{~b} & 2 & 0 & \mathrm{M} \\
\hline \text { 0x2b } & 00101011 & 2 & 5 & 1 & \mathrm{M} \\
\hline \text { 0x02 } & 00000010 & 0 & 1 & 0 & \mathrm{H} \\
\hline \text { 0xbf } & 10111111 & \mathrm{~b} & 7 & 1 & \mathrm{M} \\
\hline \text { 0x58 } & 01011000 & 5 & 4 & 0 & \mathrm{M} \\
\hline \text { 0xbe } & 10111110 & \mathrm{~b} & 6 & 0 & \mathrm{H} \\
\hline \text { 0x0e } & 00001110 & 0 & 7 & 0 & \mathrm{M} \\
\hline \text { 0xb5 } & 10110101 & \mathrm{~b} & 2 & 1 & \mathrm{H} \\
\hline \text { 0x2c } & 00101100 & 2 & 6 & 0 & \mathrm{M} \\
\hline \text { 0xba } & 10111010 & \mathrm{~b} & 5 & 0 & \mathrm{M} \\
\hline \text { 0xfd } & 11111101 & \mathrm{f} & 6 & 1 & \mathrm{M} \\
\hline
\end{array}
$$

****

![](https://obsidian-1317758465.cos.ap-shanghai.myqcloud.com/images/20230507234909.png)
## 5.5（重要！考试类似题型）

### 5.5.1
因为它的偏移有5位，也就是说块的大小为$2^5=32$个字节，也即4个字。

### 5.5.2
因为它的索引有5位，所以块的个数为32个。

### 5.5.3

总共有32个块，每个块有32个字节，所以总共存储了$32*32*8=8192$ bits. 而每个块有54位的标记和1个valid位，所以总共需要$8192+32*54+32=9952$ bits. 比率为：1.214
### 5.5.4
$$
\begin{array}{|c|c|c|c|c|c|c|}
\hline \text { 字节地址 } & \text { 二进制地址 } & \text { 标记 } & \text { 索引 } & \text { 偏移位 } & \text { 命中/未命中 } & \text{替换了的字节}\\
\hline \text { 0x00 } & 00|00000|00000 & 0 x 0 & 0 x 00 & 0 x 00 & \mathrm{M} & \\
\hline \text { 0x04 } & 00|00000|00100 & 0 x 0 & 0 x 00 & 0 x 04 & \mathrm{H} & \\
\hline \text { 0x10 } & 000000010000 & 0 x 0 & 0 x 00 & 0 x 10 & \mathrm{H} & \\
\hline \text { 0x84 } & 000010000100 & 0 x 0 & 0 x 04 & 0 x 04 & \mathrm{M} & \\
\hline \text { 0xe8 } & 000011101000 & 0 x 0 & 0 x 07 & 0 x 08 & \mathrm{M} & \\
\hline \text { 0xa0 } & 000010100000 & 0 x 0 & 0 x 05 & 0 x 00 & \mathrm{M} & \\
\hline \text { 0x400 } & 010000000000 & 0 x 1 & 0 x 00 & 0 x 00 & \mathrm{M} & \text { 0x00-0x1F } \\
\hline \text { 0x1e } & 000000011110 & 0 x 0 & 0 x 00 & 0 x 1 \mathrm{e} & \mathrm{M} & \text { 0x400-0x41F } \\
\hline \text { 0x8c } & 000010001100 & 0 x 0 & 0 x 04 & 0 x 0 c & \mathrm{H} & \\
\hline \text { 0xc1c } & 110000011100 & 0 x 3 & 0 x 00 & 0 x 1 \mathrm{c} & \mathrm{M} & 0 x 00-0 x 1 \mathrm{~F} \\
\hline \text { 0xb4 } & 000010110100 & 0 x 0 & 0 x 05 & 0 x 14 & \mathrm{H} & \\
\hline \text { 0x884 } & 10|00100|00100 & 0 x 2 & 0 x 04 & 0 x 04 & \mathrm{M} & \text { 0x80-0x9f } \\
\hline
\end{array}
$$

### 5.5.5

4 / 12 = 33.33%

### 5.5.6


<索引，标签，数据>, 这里数据是一个范围，因为offset的原因。

<0, 3, Mem[0xC00]-Mem[0xC1F]> 

<4, 2, Mem[0x880]-Mem[0x89f]> 

<5, 0, Mem[0x0A0]-Mem[0x0Bf]>

<7, 0, Mem[0x0e0]-Mem[0x0ff]>


*****

![image.png](https://obsidian-1317758465.cos.ap-shanghai.myqcloud.com/images/20230507235642.png)
## 5.9

### 5.9.1
设失效率为 $\alpha$，则额外产生的延迟为 $20\times B \times \alpha$

$$
\begin{aligned}
& Block=8: 0.040 \times(20 \times 8)=6.40 \\ \\
& Block=16: 0.030 \times(20 \times 16)=9.60 \\ \\
& Block=32: 0.020 \times(20 \times 32)=12.80 \\ \\
& Block=64: 0.015 \times(20 \times 64)=19.20 \\ \\ 
& Block=128: 0.010 \times(20 \times 128)=25.60
\end{aligned}
$$

可见块大小为8是最优的。

### 5.9.2

$$
\begin{aligned}
& Block=8: 0.040 \times(24+8)=1.28 \\ \\
& Block=16: 0.030 \times(24+16)=1.20 \\ \\
& Block=32: 0.020 \times(24+32)=1.12 \\ \\
& Block=64: 0.015 \times(24+64)=1.32 \\ \\
& Block=128: 0.010 \times(24+128)=1.52
\end{aligned}
$$

可见此时块大小为32是最优的。

### 5.9.3
当失效延迟为定值时，由表中数据可知，显然最优块大小是128。


*****

### 5.14
![image.png](https://obsidian-1317758465.cos.ap-shanghai.myqcloud.com/images/20230508225350.png)


#### 5.14.1

$2^p \ge p+d+1,d=128 \Rightarrow p=8$

我们还需要额外一位计算整个字的偶校验，所以总共需要9位。

#### 5.14.2

* 对于5.14.1, 相对奇偶校验位数是8/64=12.5%, 可以纠正的相对错误数是1/72$\approx 1.4$%，所以成本性能比为$\frac{12.5}{1.4}\approx 8.9$
* 对于SEC/DED ECC, 相对奇偶检验位数是$\frac{9}{128}\approx 7.0$%, 可以纠正的相对错误数是$\frac{1}{137}\approx 0.73$%, 所以成本性能比为$\frac{7.0}{0.73}\approx 9.6$

可见SEC/DED ECC更好。

#### 5.14.3
0x375 = 0011|0111|0101, $p_{1}=H(p_{1}p_{2}p_{3})$
* 1,3,5,7,9,11, $p_{1}=0$
* 2,3,6,7,10,11,$p_{2}=0$
* 4,5,6,7,12,$p_{3}=0$
* $p_{4}=1$

所以0b1000 = 8, 即第8位bit有错误。所以更正后应为0011|0110|0101 = 0x365

****


## 5.16
![image.png|1000](https://obsidian-1317758465.cos.ap-shanghai.myqcloud.com/images/20230508231709.png)

### 5.16.1
因为页的大小是4KiB, 即 $2^{12}$ 字节，所以虚拟页号为十六进制中的左数第一位。TLB的标签即为虚拟页号，以下表格展示了上述每一次访问中TLB是否命中，在页表中是否命中，是否会造成缺页，以及TLB的更新状态。

![TLB.png|700](https://obsidian-1317758465.cos.ap-shanghai.myqcloud.com/images/TLB.png)



***
![image.png|1000](https://obsidian-1317758465.cos.ap-shanghai.myqcloud.com/images/20230508234329.png)
## 5.21

### 5.21.1
CPI = 1.5 + 120/10000 × (15 + 175) = 3.78

* 如果VMM的开销加倍：CPI = 1.5 + 120/10000 × (15 + 350) = 5.88

* 如果VMM的开销减半：CPI = 1.5 + 120/10000 × (15 + 87.5) = 2.73

假如没有VMM开销，CPI=1.5 + 120/10000\*15 = 1.68.

设VMM开销为x，则CPI=1.5 + 120/10000\*(15+x) < 1.1 \* 1.68, 解得 x 小于等于14 个时钟周期。


### 5.21.2

* 非虚拟化系统：CPI = 1.5 + 120/10000 × 15 + 30/10000 × 1100 = 4.98

* 虚拟化系统：CPI=1.5 + 120/10000 × (15 + 175) + 30/10000 × (1100 + 175) = 7.60

I/O访问折半后，

* 非虚拟化系统：CPI=1.5 + 120/10000 × 15 + 15/10000 × 1100 = 3.33

* 虚拟化系统：CPI=1.5 + 120/10000 × (15 + 175) + 15/10000 × (1100 + 175) = 5.69