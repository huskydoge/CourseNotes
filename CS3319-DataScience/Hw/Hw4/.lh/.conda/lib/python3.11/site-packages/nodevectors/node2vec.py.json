{
    "sourceFile": ".conda/lib/python3.11/site-packages/nodevectors/node2vec.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1715346667628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1715346849282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -128,9 +128,9 @@\n         w2v_t = time.time()\n         # Train gensim word2vec model on random walks\n         self.model = gensim.models.Word2Vec(\n             sentences=self.walks,\n-            vector_size=self.n_components,\n+            size=self.n_components,\n             **self.w2vparams)\n         if not self.keep_walks:\n             del self.walks\n         if self.verbose:\n"
                }
            ],
            "date": 1715346667628,
            "name": "Commit-0",
            "content": "import numba\nimport numpy as np\nimport pandas as pd\nimport time\nimport warnings\n\n# Gensim triggers automatic useless warnings for windows users...\nwarnings.simplefilter(\"ignore\", category=UserWarning)\nimport gensim\nwarnings.simplefilter(\"default\", category=UserWarning)\n\n\nimport csrgraph as cg\nfrom nodevectors.embedders import BaseNodeEmbedder\n\nclass Node2Vec(BaseNodeEmbedder):\n    def __init__(\n        self, \n        n_components=32,\n        walklen=30, \n        epochs=20,\n        return_weight=1.,\n        neighbor_weight=1.,\n        threads=0, \n        keep_walks=False,\n        verbose=True,\n        w2vparams={\"window\":10, \"negative\":5, \"iter\":10,\n                   \"batch_words\":128}):\n        \"\"\"\n        Parameters\n        ----------\n        walklen : int\n            length of the random walks\n        epochs : int\n            number of times to start a walk from each nodes\n        threads : int\n            number of threads to use. 0 is full use\n        n_components : int\n            number of resulting dimensions for the embedding\n            This should be set here rather than in the w2vparams arguments\n        return_weight : float in (0, inf]\n            Weight on the probability of returning to node coming from\n            Having this higher tends the walks to be \n            more like a Breadth-First Search.\n            Having this very high  (> 2) makes search very local.\n            Equal to the inverse of p in the Node2Vec paper.\n        neighbor_weight : float in (0, inf]\n            Weight on the probability of visitng a neighbor node\n            to the one we're coming from in the random walk\n            Having this higher tends the walks to be \n            more like a Depth-First Search.\n            Having this very high makes search more outward.\n            Having this very low makes search very local.\n            Equal to the inverse of q in the Node2Vec paper.\n        keep_walks : bool\n            Whether to save the random walks in the model object after training\n        w2vparams : dict\n            dictionary of parameters to pass to gensim's word2vec\n            Don't set the embedding dimensions through arguments here.\n        \"\"\"\n        if type(threads) is not int:\n            raise ValueError(\"Threads argument must be an int!\")\n        if walklen < 1 or epochs < 1:\n            raise ValueError(\"Walklen and epochs arguments must be > 1\")\n        self.n_components = n_components\n        self.walklen = walklen\n        self.epochs = epochs\n        self.keep_walks = keep_walks\n        if 'size' in w2vparams.keys():\n            raise AttributeError(\"Embedding dimensions should not be set \"\n                + \"through w2v parameters, but through n_components\")\n        self.w2vparams = w2vparams\n        self.return_weight = return_weight\n        self.neighbor_weight = neighbor_weight\n        if threads == 0:\n            threads = numba.config.NUMBA_DEFAULT_NUM_THREADS\n        self.threads = threads\n        w2vparams['workers'] = threads\n        self.verbose = verbose\n\n    def fit(self, G):\n        \"\"\"\n        NOTE: Currently only support str or int as node name for graph\n        Parameters\n        ----------\n        G : graph data\n            Graph to embed\n            Can be any graph type that's supported by csrgraph library\n            (NetworkX, numpy 2d array, scipy CSR matrix, CSR matrix components)\n        \"\"\"\n        if not isinstance(G, cg.csrgraph):\n            G = cg.csrgraph(G, threads=self.threads)\n        if G.threads != self.threads:\n            G.set_threads(self.threads)\n        # Because networkx graphs are actually iterables of their nodes\n        #   we do list(G) to avoid networkx 1.X vs 2.X errors\n        node_names = G.names\n        if type(node_names[0]) not in [int, str, np.int32, np.uint32, \n                                       np.int64, np.uint64]:\n            raise ValueError(\"Graph node names must be int or str!\")\n        # Adjacency matrix\n        walks_t = time.time()\n        if self.verbose:\n            print(\"Making walks...\", end=\" \")\n        self.walks = G.random_walks(walklen=self.walklen, \n                                    epochs=self.epochs,\n                                    return_weight=self.return_weight,\n                                    neighbor_weight=self.neighbor_weight)\n        if self.verbose:\n            print(f\"Done, T={time.time() - walks_t:.2f}\")\n            print(\"Mapping Walk Names...\", end=\" \")\n        map_t = time.time()\n        self.walks = pd.DataFrame(self.walks)\n        # Map nodeId -> node name\n        node_dict = dict(zip(np.arange(len(node_names)), node_names))\n        for col in self.walks.columns:\n            self.walks[col] = self.walks[col].map(node_dict).astype(str)\n        # Somehow gensim only trains on this list iterator\n        # it silently mistrains on array input\n        self.walks = [list(x) for x in self.walks.itertuples(False, None)]\n        if self.verbose:\n            print(f\"Done, T={time.time() - map_t:.2f}\")\n            print(\"Training W2V...\", end=\" \")\n            if gensim.models.word2vec.FAST_VERSION < 1:\n                print(\"WARNING: gensim word2vec version is unoptimized\"\n                    \"Try version 3.6 if on windows, versions 3.7 \"\n                    \"and 3.8 have had issues\")\n        w2v_t = time.time()\n        # Train gensim word2vec model on random walks\n        self.model = gensim.models.Word2Vec(\n            sentences=self.walks,\n            vector_size=self.n_components,\n            **self.w2vparams)\n        if not self.keep_walks:\n            del self.walks\n        if self.verbose:\n            print(f\"Done, T={time.time() - w2v_t:.2f}\")\n\n    def fit_transform(self, G):\n        \"\"\"\n        NOTE: Currently only support str or int as node name for graph\n        Parameters\n        ----------\n        G : graph data\n            Graph to embed\n            Can be any graph type that's supported by csrgraph library\n            (NetworkX, numpy 2d array, scipy CSR matrix, CSR matrix components)\n        \"\"\"\n        if not isinstance(G, cg.csrgraph):\n            G = cg.csrgraph(G, threads=self.threads)\n        self.fit(G)\n        w = np.array(\n            pd.DataFrame.from_records(\n            pd.Series(np.arange(len(G.nodes())))\n              .apply(self.predict)\n              .values)\n        )\n        return w\n    \n    def predict(self, node_name):\n        \"\"\"\n        Return vector associated with node\n        node_name : str or int\n            either the node ID or node name depending on graph format\n        \"\"\"\n        # current hack to work around word2vec problem\n        # ints need to be str -_-\n        if type(node_name) is not str:\n            node_name = str(node_name)\n        return self.model.wv.__getitem__(node_name)\n\n    def save_vectors(self, out_file):\n        \"\"\"\n        Save as embeddings in gensim.models.KeyedVectors format\n        \"\"\"\n        self.model.wv.save_word2vec_format(out_file)\n\n    def load_vectors(self, out_file):\n        \"\"\"\n        Load embeddings from gensim.models.KeyedVectors format\n        \"\"\"\n        self.model = gensim.wv.load_word2vec_format(out_file)"
        }
    ]
}